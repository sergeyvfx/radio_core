// Copyright (c) 2021 radio core authors
//
// SPDX-License-Identifier: MIT

#pragma once

#include <limits>

#include "radio_core/math/math.h"

namespace radio_core {

// Follow the STL naming convention.
//
// NOLINTBEGIN(readability-identifier-naming)

// Produces random floating-point values x, uniformly distributed on the
// interval [a, b), that is, distributed according to the probability density
// function:
//
//    P(x|a,b) = 1 / (b - a)
//
// A simple and portable implementation of `std::uniform_real_distribution`.
template <class RealType>
class UniformRealDistribution {
 public:
  using result_type = RealType;

  constexpr UniformRealDistribution() : UniformRealDistribution(0) {}

  // a - the a distribution parameter (minimum value).
  // b - the b distribution parameter (maximum value).
  constexpr UniformRealDistribution(RealType a, RealType b = 1)
      : a_(a), b_(b) {}

  // Resets the internal state of the distribution object. After a call to this
  // function, the next call to operator() on the distribution object will not
  // be dependent on previous calls to operator().
  inline void reset() {}

  // Returns the parameters the distribution has been constructed with.
  constexpr auto a() const -> result_type { return a_; }
  constexpr auto b() const -> result_type { return b_; }

  // Returns the minimum and maximum values potentially generated by the
  // distribution.
  constexpr auto min() const -> result_type { return a(); }
  constexpr auto max() const -> result_type { return b(); }

  // Generates random numbers that are distributed according to the associated
  // probability function. The entropy is acquired by calling `g.operator()`.
  template <class Generator>
  inline auto operator()(Generator& g) const -> result_type {
    const result_type scale = (b_ - a_) / (result_type(g.max() - g.min()));
    return (g() - g.min()) * scale + a_;
  }

 private:
  result_type a_;
  result_type b_;
};

// Generates random numbers according to the Normal (or Gaussian) random number
// distribution. It is defined as:
//
//   f(x; μ,σ) = 1/(σ*Sqrt(2*pi)) * Exp(-1/2*((x-μ)/σ)^2)
//
// Here μ is the mean and σ is the standard deviation (stddev).
//
// A simple and portable implementation of `std::normal_distribution`.
template <class RealType>
class NormalDistribution {
 public:
  using result_type = RealType;

  constexpr NormalDistribution() : NormalDistribution(0) {}
  constexpr explicit NormalDistribution(RealType mean, RealType stddev = 1)
      : mean_(mean), stddev_(stddev) {}

  // Resets the internal state of the distribution object. After a call to this
  // function, the next call to operator() on the distribution object will not
  // be dependent on previous calls to operator().
  inline void reset() { has_z1_value_ = false; }

  // Returns the parameters the distribution was constructed with.
  constexpr auto mean() const -> result_type { return mean_; }
  constexpr auto stddev() const -> result_type { return stddev_; }

  // Returns the minimum and maximum values potentially generated by the
  // distribution.
  constexpr auto min() const -> result_type {
    return -std::numeric_limits<result_type>::infinity();
  }
  constexpr auto max() const -> result_type {
    return std::numeric_limits<result_type>::infinity();
  }

  // Generates random numbers that are distributed according to the associated
  // probability function. The entropy is acquired by calling `g.operator()`.
  template <class Generator>
  auto operator()(Generator& g) -> result_type {
    // Box–Muller transform, polar form:
    //
    //   https://wikipedia.org/wiki/Box%E2%80%93Muller_transform
    //
    // Naming of variables follows the convention in the article.
    // Basic idea is to generate a pair or random values, use one to generate
    // current sample of the normal distribution and save another value for the
    // next request of the normally distributed value.
    //
    // Similar implementations and comments:
    //
    //   https://stackoverflow.com/a/34962942
    //   https://stackoverflow.com/a/47615155
    result_type z0;

    if (has_z1_value_) {
      has_z1_value_ = false;
      z0 = z1_;
    } else {
      UniformRealDistribution<result_type> uniform_unit_distribution(-1.0f,
                                                                     1.0f);
      result_type u;
      result_type v;
      result_type s;

      do {
        u = uniform_unit_distribution(g);
        v = uniform_unit_distribution(g);
        s = u * u + v * v;
      } while (s >= 1 || s == 0);

      const result_type term = Sqrt(-2 * Log(s) / s);

      z0 = u * term;

      has_z1_value_ = true;
      z1_ = v * term;
    }

    return z0 * stddev() + mean();
  }

 private:
  result_type mean_;
  result_type stddev_;

  bool has_z1_value_{false};
  result_type z1_{};
};

// NOLINTEND(readability-identifier-naming)

}  // namespace radio_core
