// Copyright (c) 2022 radio core authors
//
// SPDX-License-Identifier: MIT

#include "radio_core/signal/decimator.h"

#include <array>
#include <span>

#include "radio_core/signal/local_oscillator.h"
#include "radio_core/unittest/test.h"

namespace radio_core::signal {

TEST(Decimator, Basic) {
  constexpr int kNum44100Samples = 44100 * 2;

  Decimator<float> decimator(2);

  // Generate 1000 Hz sinewave at the original sample rate.
  LocalOscillator<float> oscillator44100(1000, 44100);
  std::array<float, kNum44100Samples> samples44100;
  for (int i = 0; i < kNum44100Samples; ++i) {
    samples44100[i] = oscillator44100.Sine();
  }

  // Over-allocate the destination samples array to silence -rray-bounds warning
  // generated by GCC 12.2.0. The compiler only sees that there is possible copy
  // from source to destination, but it ignores the fact that such copy is done
  // from within a condition `ratio == 1`.
  std::array<float, 2 * 44100> samples22050;
  const std::span<float> decimated = decimator(samples44100, samples22050);
  EXPECT_EQ(decimated.size(), 44100);

  // Skip first half: thats where the filter state might not have been fully
  // stabilized yet, making it hard to compare.
  std::span clean22050(samples22050.begin() + 22050, samples22050.end());

  LocalOscillator<float> oscillator22050(1000, 22050);
  // Offset the oscillator to align with the beginning of the sinewave which has
  // a delay w.r.t. the input sinewave.
  //
  // TODO(sergey): Make this calculation more scientific. Currently it is done
  // by plotting the signal. Or find a way to test the signal is a sinewave with
  // a known frequency but unknown phase.
  oscillator22050.OffsetPhase((-32.0f + 0.45f) * 2.0f * constants::pi_v<float> *
                              1000.0f / 22050.0f);
  for (int i = 0; i < 10; ++i) {
    const float sample = oscillator22050.Sine();
    EXPECT_NEAR(clean22050[i], sample, 1e-3f);
  }
}

TEST(Decimator, CalcNeededOutputBufferSize) {
  Decimator<float> decimator(10);
  EXPECT_EQ(decimator.CalcNeededOutputBufferSize(20), 2);
  EXPECT_EQ(decimator.CalcNeededOutputBufferSize(21), 3);
}

}  // namespace radio_core::signal
