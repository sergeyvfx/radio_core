// Copyright (c) 2021 radio core authors
//
// SPDX-License-Identifier: MIT

#include "radio_core/protocol/datalink/ax25/decoder.h"

#include <array>

#include "radio_core/base/byte_util.h"
#include "radio_core/unittest/mock.h"
#include "radio_core/unittest/test.h"

namespace radio_core::protocol::datalink::ax25 {

using testing::Eq;
using testing::Pointwise;

TEST(Decoder, TooShort) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_FALSE(result.Ok());
  EXPECT_EQ(result.GetError(), Decoder::Error::kUnavailable);
  EXPECT_FALSE(result.HasValue());
}

TEST(Decoder, WrongFCS) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x61,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20,
      0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,  // Information
      0xff, 0xff,                          // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_FALSE(result.Ok());
  EXPECT_EQ(result.GetError(), Decoder::Error::kChecksumMismatch);
  EXPECT_TRUE(result.HasValue());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM"));
  EXPECT_EQ(message.address.destination, Address("NJ7P"));
  EXPECT_TRUE(message.address.repeaters.IsEmpty());
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(message.information, "Hello, World!");
}

TEST(Decoder, SimpleFrameAPI) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x61,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20,
      0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,  // Information
      0xff, 0x31,                          // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_TRUE(result.Ok());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM"));
  EXPECT_EQ(message.address.destination, Address("NJ7P"));
  EXPECT_TRUE(message.address.repeaters.IsEmpty());
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(message.information, "Hello, World!");
}

TEST(Decoder, SimpleFrameByteAPI) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x61,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20,
      0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,  // Information
      0xff, 0x31,                          // FCS.
  });

  Decoder decoder;

  const Result begin_result = decoder(FrameMarker::kBegin);
  EXPECT_FALSE(begin_result.Ok());
  EXPECT_EQ(begin_result.GetError(), Decoder::Error::kUnavailable);

  for (const std::byte byte : kEncodedMessage) {
    const Decoder::Result result = decoder(FrameByte(byte));
    EXPECT_FALSE(result.Ok());
    EXPECT_EQ(result.GetError(), Decoder::Error::kUnavailable);
    EXPECT_FALSE(result.HasValue());
  }

  const Decoder::Result result = decoder(FrameMarker::kEnd);
  EXPECT_TRUE(result.Ok());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM"));
  EXPECT_EQ(message.address.destination, Address("NJ7P"));
  EXPECT_TRUE(message.address.repeaters.IsEmpty());
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(message.information, "Hello, World!");
}

TEST(Decoder, SSID) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x7a,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x77,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20,
      0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,  // Information.
      0xb3, 0x05,                          // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_TRUE(result.Ok());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM", 11));
  EXPECT_EQ(message.address.destination, Address("NJ7P", 13));
  EXPECT_TRUE(message.address.repeaters.IsEmpty());
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(message.information, "Hello, World!");
}

TEST(Decoder, Repeater) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x60,  // Source.
      0x9c, 0x82, 0x62, 0xa6, 0xa6, 0x40, 0x61,  // Repeater.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20,
      0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,  // Information.
      0x12, 0x6d,                          // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_TRUE(result.Ok());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM"));
  EXPECT_EQ(message.address.destination, Address("NJ7P"));
  EXPECT_EQ(message.address.repeaters.size(), 1);
  EXPECT_THAT(message.address.repeaters,
              Pointwise(Eq(), std::to_array({Address("NA1SS")})));
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(message.information, "Hello, World!");
}

TEST(Decoder, MaxInformation) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x61,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57,  // Information
      0x4e, 0x7c,              // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_TRUE(result.Ok());

  const Message& message = result.GetValue();

  EXPECT_EQ(message.address.source, Address("N7LEM"));
  EXPECT_EQ(message.address.destination, Address("NJ7P"));
  EXPECT_EQ(message.control, ControlBits::Unnumbered::kUI);
  EXPECT_EQ(message.pid, PID::kNoLayer3);
  EXPECT_EQ(
      message.information,
      "Hello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, "
      "WHello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, "
      "WHello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, WHello, "
      "WHello, WHello, WHello, WHello, WHello, W");
}

TEST(Decoder, LongInformation) {
  constexpr auto kEncodedMessage = ToBytesArray({
      0x9c, 0x94, 0x6e, 0xa0, 0x40, 0x40, 0x60,  // Destination.
      0x9c, 0x6e, 0x98, 0x8a, 0x9a, 0x40, 0x61,  // Source.
      0x03,                                      // Control.
      0xf0,                                      // PID.
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x2c, 0x20, 0x57, 0x48,  // Information
      0xff, 0x31,                    // FCS.
  });

  Decoder decoder;

  const Decoder::Result result = decoder(kEncodedMessage);
  EXPECT_FALSE(result.Ok());
  EXPECT_EQ(result.GetError(), Decoder::Error::kResourceExhausted);
  EXPECT_FALSE(result.HasValue());
}

}  // namespace radio_core::protocol::datalink::ax25
